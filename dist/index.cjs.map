{"version":3,"sources":["../src/index.ts","../src/utils/ztm.ts","../src/utils/common.ts","../src/utils/mergeRegex.ts","../src/utils/parsers.ts"],"sourcesContent":["import { AsyncLocalStorage } from \"node:async_hooks\";\nimport * as z from \"zod/v4\";\nimport { ZodRawShape } from \"zod/v4\";\nimport { IGenerateSchema } from \"./types\";\nimport { _Schema } from \"./types/mongoose\";\nimport { normalizeOptions } from \"./utils\";\nimport { parseObject } from \"./utils/parsers\";\nimport { ztm } from \"./utils/ztm\";\n\n/*   k: z.enum([\"ala\", \"321321\"]),\n  t: z\n    .string()\n    .min(10, {\n      error: \"To small\",\n    })\n    .max(100)\n    .trim()\n    .overwrite((v) => v.toLocaleLowerCase())\n    .lowercase()\n    .regex(/^s/)\n    .regex(/^sewa/),\n\n  bruh: z\n    .number()\n    .gt(10, {\n      error: \"To small\",\n    })\n\n    .default(() => Math.floor(Math.random() * 1000)),\n  bruh2: z.number().default(123),\n */\n/*   test2: z.object({\n    test: z.object({\n      t: z.string(),\n    }),\n  }), */\n// test3: z.bigint(),\n\nexport const schema = z.object({\n  test2: z.object({\n    t: z\n      .string()\n      .lowercase()\n      .default(() => crypto.randomUUID()),\n    t2: z.string(),\n  }),\n  k: z.null(),\n  abc: z.record(\n    z.string(),\n    z.object({\n      test: z.string(),\n    })\n  ),\n  tae: z.union([z.string(), z.number()]),\n  d: z\n    .date()\n    .min(Date.now())\n    .max(Date.now() + 1),\n  k3: z.number().min(132),\n});\n\nexport const asyncLocalOptions = new AsyncLocalStorage<\n  IGenerateSchema<ZodRawShape>[\"options\"]\n>();\n\nexport const generateRawSchema = <T extends ZodRawShape>({\n  ...props\n}: IGenerateSchema<T>): _Schema<T> => {\n  return asyncLocalOptions.run(normalizeOptions(props.options), () => {\n    return parseObject({\n      ...props,\n    });\n  });\n};\n\nconsole.log(\n  generateRawSchema({\n    schema,\n    options: {\n      tae: ztm\n        .sparse()\n        .unique()\n        .get((v) => v)\n        .set((v) => v)\n        .ref(\"dwa\"),\n      test2: {\n        t2: ztm.id(),\n        t: { sparse: true },\n      },\n    },\n  })\n);\n","import { ZodRawShape } from \"zod/v4\";\nimport { SchemaOptions } from \"../types\";\n\ntype ZtmTransform = (v: any) => any;\n\n// Recursive schema-aware options\n\nexport interface _ZTM {\n  type?: \"ObjectID\" | \"UUID\";\n  unique?: boolean;\n  sparse?: boolean;\n  index?: boolean;\n  immutable?: boolean;\n  ref?: string;\n  refPath?: string;\n  get?: ZtmTransform;\n  set?: ZtmTransform;\n}\nexport interface IZtm {\n  _ztm: _ZTM;\n\n  unique(): IZtm;\n  sparse(): IZtm;\n  index(): IZtm;\n  immutable(): IZtm;\n  ref(ref: string): IZtm;\n  refPath(refPath: string): IZtm;\n  get(transform: ZtmTransform): IZtm;\n  set(transform: ZtmTransform): IZtm;\n\n  uuid(): IZtm;\n  id(): IZtm;\n}\n\nexport interface ZtmObjectBuilder {}\n\nexport const isZtm = (obj: any): obj is IZtm => {\n  return (\n    obj !== null &&\n    typeof obj === \"object\" &&\n    \"_ztm\" in obj &&\n    typeof obj.unique === \"function\" &&\n    typeof obj.sparse === \"function\" &&\n    typeof obj.index === \"function\" &&\n    typeof obj.immutable === \"function\" &&\n    typeof obj.ref === \"function\" &&\n    typeof obj.refPath === \"function\" &&\n    typeof obj.get === \"function\" &&\n    typeof obj.set === \"function\" &&\n    typeof obj.uuid === \"function\" &&\n    typeof obj.id === \"function\"\n  );\n};\n\n// Pure factory for new, independent IZtm instances\nexport const createZtm = (state: IZtm[\"_ztm\"] = {}): IZtm => {\n  const next = (patch: Partial<IZtm[\"_ztm\"]>) =>\n    createZtm({ ...state, ...patch });\n\n  return {\n    _ztm: { ...state },\n\n    unique: () => next({ unique: true }),\n    sparse: () => next({ sparse: true }),\n    index: () => next({ index: true }),\n    immutable: () => next({ immutable: true }),\n    ref: (ref) => next({ ref }),\n    refPath: (refPath) => next({ refPath }),\n    get: (get) => next({ get }),\n    set: (set) => next({ set }),\n\n    uuid: () => next({ type: \"UUID\" }),\n    id: () => next({ type: \"ObjectID\" }),\n  };\n};\n\nexport const ztmObject = <T extends ZodRawShape>(\n  values: SchemaOptions<T>\n): SchemaOptions<T> => values;\n\nexport const ztm = createZtm();\n","import { ZodRawShape, ZodType } from \"zod/v4\";\nimport { NestedRecord, Paths, PropertyAtPath, SchemaOptions } from \"../types\";\nimport { _ZTM, isZtm } from \"./ztm\";\n\nexport const getInnerType = (field: ZodType<any>): ZodType<any> => {\n  return (\"innerType\" in field.def && field.def.innerType) as ZodType<any>;\n};\n\nexport const getInnerElement = (field: ZodType<any>): ZodType<any> => {\n  return (\"element\" in field && field.element) as ZodType<any>;\n};\n\n// Check if value is defined, and reinforce the TS typings.\nexport const isDefined = <T>(value: T | undefined | null): value is T => {\n  return value !== undefined && value !== null;\n};\n\nexport function safeAccessProperty<\n  O extends object,\n  K extends PropertyKey\n>(params: {\n  object: O | null | undefined;\n  key: K;\n}): O[K & keyof O] | undefined {\n  const { object, key } = params;\n\n  if (typeof object !== \"object\" || object === null) return undefined;\n\n  if (key in object) {\n    return (object as any)[key];\n  }\n\n  return undefined;\n}\n\nexport const getFieldHasOption = ({\n  properties,\n  parentStack,\n  key,\n}: {\n  properties: Paths | undefined;\n  parentStack: string[];\n  key: string;\n}) =>\n  typeof properties !== \"undefined\" &&\n  (Array.isArray(properties)\n    ? properties.includes(parentStack.concat(key).join(\".\"))\n    : Boolean(\n        getFlattenedProperty({\n          key: parentStack.concat(key),\n          object: parentStack,\n        })\n      ));\n\nexport const getFlattenedProperty = <\n  T extends object,\n  K extends readonly string[]\n>({\n  object,\n  key,\n}: {\n  object: T;\n  key: K;\n}): PropertyAtPath<T, K> | undefined => {\n  if (!object) return undefined;\n\n  const keys = key;\n\n  let item: unknown = object;\n\n  for (const k of keys) {\n    if (item === null || item === undefined || typeof item !== \"object\") {\n      return undefined;\n    }\n\n    item = (item as Record<string, unknown>)[k];\n  }\n\n  return item as PropertyAtPath<T, K>; //\n};\n\nexport const getFieldOptions = <T>({\n  properties,\n  parentStack,\n  key,\n}: {\n  properties: NestedRecord<T> | undefined;\n  parentStack: string[];\n  key: string;\n}): _ZTM => {\n  if (!properties) return {};\n\n  const fullKey = parentStack.concat(key);\n\n  return (\n    getFlattenedProperty({\n      key: fullKey,\n      object: properties,\n    }) || {}\n  );\n};\n\nexport const normalizeOptions = <T extends ZodRawShape>(\n  options?: SchemaOptions<T>\n) => {\n  let object: any = {};\n\n  if (!options) return object;\n\n  Object.entries(options).forEach(([key, value]) => {\n    if (isZtm(value)) {\n      object[key] = value._ztm;\n    } else if (value && typeof value === \"object\" && !Array.isArray(value)) {\n      object[key] = normalizeOptions(value as any); // Recursively normalize nested objects\n    } else {\n      object[key] = value;\n    }\n  });\n\n  return object;\n};\n","export interface MergeRegexOptions {\n  preserveAnchors?: boolean;\n  mergeAnchors?: boolean;\n  deduplicate?: boolean;\n  wrapNonCapturingGroup?: boolean;\n}\n\nexport const mergeRegex = (\n  args: RegExp[],\n  options: MergeRegexOptions = {}\n): RegExp => {\n  const {\n    preserveAnchors = true,\n    mergeAnchors = false,\n    deduplicate = true,\n    wrapNonCapturingGroup = false,\n  } = options;\n\n  if (!args.length) throw new Error(\"No regex expressions provided.\");\n\n  const flags = args[0].flags;\n\n  const sources: string[] = [];\n\n  let anchorStart = true;\n  let anchorEnd = true;\n\n  for (let i = 0; i < args.length; i++) {\n    const arg = args[i];\n\n    if (!(arg instanceof RegExp)) {\n      throw new Error(`Argument ${i} is not a RegExp`);\n    }\n\n    let source = arg.source;\n\n    if (!preserveAnchors) {\n      const startsWithAnchor = source.startsWith(\"^\");\n      const endsWithAnchor = /[^\\\\]\\$$/.test(source);\n\n      if (startsWithAnchor) source = source.slice(1);\n      if (endsWithAnchor) source = source.replace(/\\$$/, \"\");\n\n      if (!startsWithAnchor) anchorStart = false;\n      if (!endsWithAnchor) anchorEnd = false;\n    }\n\n    sources.push(source);\n  }\n\n  const uniqueSources = deduplicate ? [...new Set(sources)] : sources;\n\n  let pattern = uniqueSources.join(\"|\");\n\n  if (uniqueSources.length > 1 || wrapNonCapturingGroup) {\n    pattern = `(?:${pattern})`;\n  }\n\n  if (mergeAnchors && !preserveAnchors) {\n    pattern = (anchorStart ? \"^\" : \"\") + pattern + (anchorEnd ? \"$\" : \"\");\n  }\n\n  return new RegExp(pattern, flags);\n};\n","import {\n  ZodArray,\n  ZodBigInt,\n  ZodBoolean,\n  ZodDate,\n  ZodDefault,\n  ZodEnum,\n  ZodMap,\n  ZodNull,\n  ZodNullable,\n  ZodNumber,\n  ZodObject,\n  ZodOptional,\n  ZodRawShape,\n  ZodRecord,\n  ZodString,\n  ZodType,\n  ZodUndefined,\n} from \"zod/v4\";\n\nimport {\n  getFieldOptions,\n  getInnerElement,\n  getInnerType,\n  isDefined,\n  safeAccessProperty,\n} from \"./common\";\n\nimport { Schema } from \"mongoose\";\nimport { asyncLocalOptions } from \"..\";\nimport { NestedRecord } from \"../types\";\nimport {\n  Field,\n  FieldMap,\n  mArray,\n  mBoolean,\n  mField,\n  mMap,\n} from \"../types/mongoose\";\nimport { mergeRegex } from \"./mergeRegex\";\nimport { _ZTM, IZtm } from \"./ztm\";\n\nexport const parseField = <T>(args: {\n  field: ZodType<T>;\n  default?: any;\n  required?: boolean;\n  options?: _ZTM;\n}): mField => {\n  const { field } = args;\n\n  if (field instanceof ZodDefault) {\n    return parseField({\n      ...args,\n      // Get the actual getter function, and not just the return.\n      default:\n        \"defaultValue\" in field.def\n          ? Object.getOwnPropertyDescriptor(field.def, \"defaultValue\")?.get\n          : undefined,\n      field: getInnerType(field),\n    });\n  } else if (field instanceof ZodObject) {\n    return parseObject({\n      ...args,\n      schema: field,\n    });\n  } else if (field instanceof ZodArray) {\n    return parseArray({\n      ...args,\n      field: getInnerElement(field),\n    });\n  } else if (field instanceof ZodNumber || field instanceof ZodBigInt) {\n    return parseNumber({\n      ...args,\n      field,\n    });\n  } else if (field instanceof ZodDate) {\n    return parseDate({\n      ...args,\n      field,\n    });\n  } else if (field instanceof ZodString || field instanceof ZodEnum) {\n    return parseString({\n      ...args,\n      field,\n    });\n  } else if (field instanceof ZodBoolean) {\n    return parseBoolean({\n      ...args,\n      field: field,\n    });\n  } else if (field instanceof ZodOptional) {\n    return parseField({\n      ...args,\n      field: getInnerType(field),\n    });\n  } else if (field instanceof ZodNullable) {\n    return parseField({\n      ...args,\n      field: getInnerType(field),\n    });\n  } else if (field instanceof ZodNull || field instanceof ZodUndefined) {\n    const type = field instanceof ZodUndefined ? undefined : null;\n\n    return parseMixed({\n      ...args,\n      field,\n      validate: {\n        validator: function (value) {\n          return value === type;\n        },\n        message: `A${[\"undefined\"].includes(String(type)) ? \"n\" : \"\"} ${String(\n          type\n        )} value is required for z.${String(type)}()`,\n      },\n    });\n  } else if (field instanceof ZodMap || field instanceof ZodRecord) {\n    return parseMap({\n      ...args,\n      field: field.valueType as ZodType,\n    });\n  } else {\n    return parseMixed({\n      ...args,\n      field,\n    });\n    throw new Error(\"Unsupported field type: \" + field._zod.def.type);\n  }\n};\n\nexport const parseMixed = (args: {\n  field: ZodType;\n  default?: any;\n  required?: boolean;\n  options?: IZtm[\"_ztm\"];\n  validate?: Field<any>[\"validate\"];\n}): mField => {\n  const { default: def, required = true, validate, options } = args;\n\n  return {\n    ...options,\n    type: Schema.Types.Mixed,\n    default: def,\n    required,\n    validate,\n  };\n};\n\nexport const parseArray = <T extends ZodType>(args: {\n  field: ZodType;\n  default?: any[];\n  required?: boolean;\n  options?: _ZTM;\n}): mArray<any> => {\n  const { field: _field, options } = args;\n\n  const field = parseField({\n    ...args,\n    options,\n  });\n\n  if (!field) throw new Error(\"Unsupported array type\");\n\n  return {\n    ...options,\n    ...args,\n    ...(field as Field<T[]>),\n    type: [field.type as any],\n  };\n};\n\nexport const parseBoolean = <T extends ZodBoolean>({\n  default: def,\n  options,\n  ...args\n}: {\n  field: T;\n  default?: boolean;\n  required?: boolean;\n  options?: _ZTM;\n}): mBoolean => {\n  return {\n    ...args,\n    ...options,\n    type: Boolean,\n  };\n};\n\nexport const parseMap = <T, K>({\n  default: def,\n  required = true,\n  options,\n  ...args\n}: {\n  field: ZodType<K>;\n  default?: () => Map<NoInfer<T>, K>;\n  options?: _ZTM;\n  required?: boolean;\n}): mMap<T, K> => {\n  const { field: _field } = args;\n\n  const field = parseField({\n    ...args,\n    options,\n  });\n\n  return {\n    ...options,\n    type: Map,\n    of: field as Field<K>,\n    default: def,\n  };\n};\n\nexport const parseDate = <T extends ZodDate>({\n  options,\n  field,\n  ...args\n}: {\n  field: T;\n  default?: Date;\n  required?: boolean;\n  options?: _ZTM;\n}): mField => {\n  // Get the greater than check\n  // can be anywhere in the checks\n  // console.log(field?.def?.checks?.[0]._zod.def?.check === \"greater_than\");\n\n  const min = field.def.checks?.find(\n    (c: any) => c._zod.def.check === \"greater_than\"\n  )?._zod?.def;\n\n  const max = field.def.checks?.find(\n    (c: any) => c._zod.def.check === \"less_than\"\n  )?._zod?.def;\n\n  return {\n    ...args,\n    ...options,\n    type: Date,\n    min: safeAccessProperty({\n      object: min,\n      key: \"value\",\n    }) satisfies number | bigint | undefined,\n    max: safeAccessProperty({\n      object: max,\n      key: \"value\",\n    }) satisfies number | bigint | undefined,\n  };\n};\n\nexport const parseNumber = <T extends ZodNumber | ZodBigInt>({\n  field,\n  options,\n  ...args\n}: {\n  field: T;\n  default?: T extends ZodNumber ? number : bigint;\n  required?: boolean;\n  options?: _ZTM;\n}): FieldMap<T> => {\n  const isNumber = field instanceof ZodNumber;\n\n  const min = field.def.checks?.find(\n    (c: any) => c._zod.def.check === \"greater_than\"\n  )?._zod?.def;\n\n  const max = field.def.checks?.find(\n    (c: any) => c._zod.def.check === \"less_than\"\n  )?._zod?.def;\n\n  return {\n    ...options,\n    ...args,\n    type: isNumber ? Number : BigInt,\n\n    // Zod translates LTE to min value + 1, and GTE to value - 1\n    min: safeAccessProperty({\n      object: min,\n      key: \"value\",\n    }) satisfies number | bigint | undefined,\n    max: safeAccessProperty({\n      object: max,\n      key: \"value\",\n    }) satisfies number | bigint | undefined,\n  } as FieldMap<T>;\n};\n\n/* \n\n TODO: Add function to parse checks, figure out all the check types and make one \"parseCheck\", then use switch case\n to parse the specific ones. Then inside the parseString etc, use the data from the checks, if the check is appropriate.\n Return the check from parseCheck as {type: \"ZodCheckRegex\"], type can get retrieved from field?.def?.checks?.[0] instanceof $ZodCheckRegex.\n And then use the info that is appropriate.\n\n*/\n/*\n  \n    console.log(\n    field?.def?.checks?.[0] instanceof $ZodCheckRegex,\n    field?.def?.checks?.[0]._zod.def?.check\n  );\n  \n  console.log(field?.def?.checks?.[0]);\n\n  {\n  traits: Set(3) { '$ZodCheckRegex', '$ZodCheckStringFormat', '$ZodCheck' },\n  def: { check: 'string_format', format: 'regex', pattern: /^s/ },\n  onattach: [ [Function (anonymous)] ],\n  constr: [Function: $ZodCheckRegex],\n  check: [Function (anonymous)],\n  deferred: []\n}\n  \n  */\n\nexport const parseString = <T extends ZodString | ZodEnum>({\n  field,\n  required = true,\n  options,\n  ...args\n}: {\n  field: T;\n  unique?: boolean;\n  default?: string;\n  required?: boolean;\n  options?: _ZTM;\n}): mField => {\n  const regexArray = field.def.checks\n    ?.filter(\n      (c: any) =>\n        c._zod.def.check === \"string_format\" && c._zod.def.format === \"regex\"\n    )\n    .map(\n      (v) =>\n        safeAccessProperty({\n          object: v._zod?.def,\n          key: \"pattern\",\n        }) as undefined | RegExp\n    )\n    .filter(isDefined); // now regexArray is RegExp[]\n\n  return {\n    ...options,\n    ...args,\n    type: String,\n\n    enum: safeAccessProperty({\n      object: field,\n      key: \"options\",\n    }) as string[] | undefined,\n\n    minLength: safeAccessProperty({\n      object: field.def.checks?.find(\n        (c: any) => c._zod.def.check === \"min_length\"\n      ),\n      key: \"min\",\n    }),\n    maxLength: safeAccessProperty({\n      object: field.def.checks?.find(\n        (c: any) => c._zod.def.check === \"max_length\"\n      ),\n      key: \"max\",\n    }),\n\n    lowercase: Boolean(\n      field.def.checks?.find(\n        (c: any) =>\n          c._zod.def.check === \"string_format\" &&\n          c._zod.def.format === \"lowercase\"\n      )\n    ),\n    uppercase: Boolean(\n      field.def.checks?.find(\n        (c: any) =>\n          c._zod.def.check === \"string_format\" &&\n          c._zod.def.format === \"uppercase\"\n      )\n    ),\n\n    regex:\n      regexArray && regexArray.length > 0 ? mergeRegex(regexArray) : undefined,\n  };\n};\n\n/* type ExtractInnerTypeNestedRecord<T> = T extends NestedRecord<infer U>\n  ? U\n  : never; */\n\nexport const parseObject = <T extends ZodRawShape>({\n  ...args\n}: {\n  schema: ZodObject<T>;\n  parentStack?: string[];\n  options?: NestedRecord<_ZTM> | _ZTM;\n}) => {\n  const { schema: obj, parentStack = [], ...options } = args;\n\n  const object: any = {};\n\n  const globalOptions = asyncLocalOptions.getStore();\n\n  for (const [key, field] of Object.entries(obj.def.shape) as [\n    string,\n    ZodType<any>\n  ][]) {\n    if (field.def.type === \"object\") {\n      object[key] = parseObject({\n        schema: field as ZodObject<any, any>,\n        parentStack: [...parentStack, key],\n        ...options,\n      });\n    } else {\n      const f = parseField({\n        field: field as ZodType<any>,\n        options: getFieldOptions({\n          properties: globalOptions,\n          parentStack,\n          key,\n        }),\n      });\n\n      object[key] = f;\n    }\n  }\n\n  return object;\n};\n"],"mappings":"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","names":["object","object","_a","_b","object"]}